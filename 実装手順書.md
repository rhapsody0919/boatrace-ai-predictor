# ボートレースAI予測アプリケーション - 実装手順書（スクレイピング版）

## Step 0: 技術スタック

- **言語**: JavaScript (ES6+)
- **フレームワーク**: React 19.2.0
- **ビルドツール**: Vite 7.2.4
- **スタイリング**: CSS（標準CSS、モジュール不使用）
- **状態管理**: React Hooks (useState, useEffect)
- **HTTPクライアント**: Fetch API (ブラウザ標準)
- **スクレイピング**: Cheerio 1.0.0（サーバーサイド）
- **バックエンド**: Vercel サーバーレス関数（API Routes）
- **デプロイ**: Vercel
- **開発ツール**: ESLint 9.39.1

## 重要な注意事項

本実装ではWebスクレイピングを使用します。以下のマナーを遵守してください：

1. **robots.txtを尊重**: スクレイピング対象サイトのrobots.txtを確認
2. **User-Agent設定**: 適切なUser-Agentを設定し、自身を識別
3. **リクエスト頻度制限**: キャッシュを実装し、過度なリクエストを避ける
4. **利用規約の確認**: 対象サイトの利用規約を確認し、遵守する
5. **エラー時即座にフォールバック**: スクレイピング失敗時はサンプルデータを使用

## Step 1: プロジェクトのセットアップと環境構築

### タスク 1.1: プロジェクトディレクトリの作成と初期化

以下のコマンドを実行し、プロジェクトの基本構造を作成します。

```bash
npm create vite@latest boatrace-ai-predictor -- --template react
cd boatrace-ai-predictor
npm install
```

### タスク 1.2: スクレイピング用ライブラリのインストール

Vercelサーバーレス関数で使用するスクレイピングライブラリをインストールします。

```bash
npm install cheerio
```

### タスク 1.3: 不要なファイルの削除

デフォルトで作成されるサンプルファイルを削除します。

```bash
rm src/App.css
rm src/assets/react.svg
rm public/vite.svg
```

### タスク 1.4: package.jsonの確認

`package.json`を開き、以下の依存関係が追加されていることを確認します。

```json
{
  "name": "boatrace-ai-predictor",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "cheerio": "^1.0.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "vite": "^7.2.4"
  }
}
```

### タスク 1.5: Vite設定ファイルの確認

`vite.config.js`を開き、Vercelデプロイ用の設定を確認します。

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  // Vercelの場合はbaseパス設定は不要（ルートパスで配信される）
})
```

## Step 2: Vercelサーバーレス関数（スクレイピング）の実装

### タスク 2.1: APIディレクトリの作成

プロジェクトルートに`api`ディレクトリを作成します。

```bash
mkdir api
```

### タスク 2.2: スクレイピング関数の実装

`api/scrape-races.js`を作成し、スクレイピング処理を実装します。

以下は、実際のボートレース公式サイト（https://www.boatrace.jp/owpc/pc/race/beforeinfo）から直前情報を取得する実装例です。

```javascript
// api/scrape-races.js
// Vercel Serverless Function for scraping boatrace data
import * as cheerio from 'cheerio';

// In-memory cache
let cache = {
  data: null,
  timestamp: null
};

const CACHE_DURATION = 5 * 60 * 1000; // 5分間キャッシュ

// レース場マッピング (1-24)
const VENUES = {
  1: '桐生', 2: '戸田', 3: '江戸川', 4: '平和島', 5: '多摩川', 6: '浜名湖',
  7: '蒲郡', 8: '常滑', 9: '津', 10: 'びわこ', 11: '住之江', 12: '尼崎',
  13: '鳴門', 14: '丸亀', 15: '児島', 16: '宮島', 17: '徳山', 18: '下関',
  19: '若松', 20: '芦屋', 21: '福岡', 22: '唐津', 23: '大村', 24: 'ボートレース'
};

// URLを生成する関数
function getUrl(date, placeCd, raceNo, content) {
  const urlBase = 'https://www.boatrace.jp/owpc/pc/race/';

  // 日付をYYYYMMDD形式に変換
  const ymd = date.replace(/-/g, '');

  // 場コードを2桁にする（10未満は0埋め）
  const jcd = placeCd < 10 ? `0${placeCd}` : `${placeCd}`;

  const url = `${urlBase}${content}?rno=${raceNo}&jcd=${jcd}&hd=${ymd}`;
  return url;
}

// 直前情報を取得する関数
async function getBeforeinfo(date, placeCd, raceNo) {
  try {
    const url = getUrl(date, placeCd, raceNo, 'beforeinfo');

    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'ja,en-US;q=0.7,en;q=0.3',
      }
    });

    if (!response.ok) {
      console.error(`HTTP error! status: ${response.status} for URL: ${url}`);
      return null;
    }

    const html = await response.text();
    const $ = cheerio.load(html);

    // 天候情報を取得
    const weatherData = [];
    $('.weather1_bodyUnitLabelData').each((i, elem) => {
      weatherData.push($(elem).text().trim());
    });

    // 天気を取得
    let weather = '';
    $('.weather1_bodyUnitLabelTitle').each((i, elem) => {
      if (i === 1) {
        weather = $(elem).text().trim();
      }
    });

    // 風向を取得
    let windDirection = 0;
    const windElem = $('p[class*="is-wind"]');
    if (windElem.length > 0) {
      const classes = windElem.attr('class');
      const windClass = classes.split(' ').find(c => c.startsWith('is-wind'));
      if (windClass) {
        windDirection = parseInt(windClass.replace('is-wind', ''));
      }
    }

    // 展示タイムとチルトの情報を取得
    const arr1 = [];
    $('.is-fs12').each((i, elem) => {
      const tds = $(elem).find('td');
      if (tds.length >= 6) {
        const et = $(tds[4]).text().trim();
        const tilt = $(tds[5]).text().trim();
        arr1.push({
          ET: et === '\xa0' || et === '' ? '' : et,
          tilt: tilt === '\xa0' || tilt === '' ? '' : tilt
        });
      }
    });

    // スタート展示情報を取得
    const arr2 = [];
    $('.table1_boatImage1').each((i, elem) => {
      const estNumber = $(elem).find('.table1_boatImage1Number').text().trim();
      const estTime = $(elem).find('.table1_boatImage1Time').text().trim();

      arr2.push({
        EST_Number: estNumber,
        EST_Time: estTime.replace('F', '-'),
        originalIndex: i + 1
      });
    });

    // スタート展示番号でソート
    arr2.sort((a, b) => {
      const aNum = parseInt(a.EST_Number) || 0;
      const bNum = parseInt(b.EST_Number) || 0;
      return aNum - bNum;
    });

    // データを統合
    const result = {
      date: date,
      placeCd: placeCd,
      raceNo: raceNo,
      weather: weather,
      airTemp: weatherData[0] ? parseFloat(weatherData[0].replace('℃', '')) : null,
      windDirection: windDirection,
      windVelocity: weatherData[1] ? parseFloat(weatherData[1].replace('m', '')) : null,
      waterTemp: weatherData[2] ? parseFloat(weatherData[2].replace('℃', '')) : null,
      waveHeight: weatherData[3] ? parseFloat(weatherData[3].replace('cm', '')) : null,
      racers: []
    };

    // 各艇のデータを統合
    for (let i = 0; i < 6; i++) {
      const racerData = {
        number: i + 1,
        ET: arr1[i] ? arr1[i].ET : '',
        tilt: arr1[i] ? arr1[i].tilt : '',
        EST: arr2[i] ? arr2[i].EST_Time : '',
        ESC: arr2[i] ? arr2[i].EST_Number : ''
      };
      result.racers.push(racerData);
    }

    return result;

  } catch (error) {
    console.error(`Error fetching beforeinfo for place ${placeCd}, race ${raceNo}:`, error.message);
    return null;
  }
}

// 今日の日付を取得 (YYYY-MM-DD形式)
function getTodayDate() {
  const today = new Date();
  const year = today.getFullYear();
  const month = String(today.getMonth() + 1).padStart(2, '0');
  const day = String(today.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

export default async function handler(req, res) {
  // CORSヘッダーの設定
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

  // OPTIONSリクエストの処理
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const now = Date.now();

  // キャッシュチェック
  if (cache.data && cache.timestamp && (now - cache.timestamp < CACHE_DURATION)) {
    console.log('Returning cached data');
    return res.status(200).json({
      success: true,
      data: cache.data,
      cached: true,
      cacheAge: Math.floor((now - cache.timestamp) / 1000)
    });
  }

  try {
    console.log('Fetching fresh data from boatrace.jp');

    const date = getTodayDate();
    const allRaces = [];

    // 全24レース場の1Rから12Rまでのデータを取得
    // ただし、効率化のため並列処理を制限
    const MAX_CONCURRENT = 3; // 同時リクエスト数を制限

    for (let placeCd = 1; placeCd <= 24; placeCd++) {
      const venueRaces = [];

      // 1Rから12Rまで取得（レース場によっては全てのレースが開催されていない場合もある）
      for (let raceNo = 1; raceNo <= 12; raceNo += MAX_CONCURRENT) {
        const promises = [];

        for (let i = 0; i < MAX_CONCURRENT && (raceNo + i) <= 12; i++) {
          promises.push(getBeforeinfo(date, placeCd, raceNo + i));
        }

        const results = await Promise.all(promises);

        // nullでないデータのみを追加
        results.forEach(result => {
          if (result) {
            venueRaces.push(result);
          }
        });

        // レート制限のため少し待機
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // このレース場でデータが取得できた場合のみ追加
      if (venueRaces.length > 0) {
        allRaces.push({
          placeCd: placeCd,
          placeName: VENUES[placeCd] || `レース場${placeCd}`,
          races: venueRaces
        });
      }
    }

    // キャッシュを更新
    cache.data = allRaces;
    cache.timestamp = now;

    console.log(`Successfully scraped ${allRaces.length} venues with race data`);

    return res.status(200).json({
      success: true,
      data: allRaces,
      cached: false,
      scrapedAt: new Date().toISOString()
    });

  } catch (error) {
    console.error('Error in scraping:', error);

    // エラー時はキャッシュがあればそれを返す
    if (cache.data) {
      console.log('Returning stale cache due to error');
      return res.status(200).json({
        success: true,
        data: cache.data,
        cached: true,
        error: 'Using stale cache due to scraping error'
      });
    }

    return res.status(500).json({
      success: false,
      error: 'Failed to scrape race data',
      message: error.message
    });
  }
}
```

**実装のポイント**:
- 全24レース場の1R～12Rを順次スクレイピング
- 同時リクエスト数を3に制限し、100ms待機することでサーバー負荷を軽減
- 取得できなかったレースはnullとして扱い、スキップ
- 5分間のメモリキャッシュでリクエスト回数を削減

### タスク 2.3: vercel.jsonの作成

プロジェクトルートに`vercel.json`を作成し、API Routesの設定とCORS設定を行います。

```json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "rewrites": [
    {
      "source": "/api/(.*)",
      "destination": "/api/$1"
    }
  ],
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        { "key": "Access-Control-Allow-Origin", "value": "*" },
        { "key": "Access-Control-Allow-Methods", "value": "GET, OPTIONS" },
        { "key": "Access-Control-Allow-Headers", "value": "Content-Type" }
      ]
    }
  ]
}
```

## Step 3: スタイルシートの作成

### タスク 3.1: グローバルスタイル（index.css）の作成

`src/index.css`を開き、グローバルスタイルを定義します。

このファイルは既にViteプロジェクトに含まれていますが、必要に応じてカスタマイズできます。デフォルトの内容をそのまま使用します。

### タスク 3.2: アプリケーションスタイル（App.css）の作成

`src/App.css`を作成し、アプリケーション固有のスタイルを定義します。

広告バナー、レースカード、予測結果などのスタイルを定義します。詳細なスタイル定義は、実際のApp.cssファイルを参照してください。

**注**: この実装では、データマッピング、API呼び出し、サンプルデータ生成などの機能はすべて`App.jsx`内に直接実装します。別ファイルに分割せず、シンプルな構成を維持します。

## Step 4: App.jsxの実装

### タスク 4.1: メインアプリケーションの実装

`src/App.jsx`を開き、メインアプリケーションロジックを実装します。

この実装では、すべてのロジック（データ取得、レース場マッピング、AI予測生成）を1つのファイルに統合しています。

```javascript
// src/App.jsx
import { useState, useEffect } from 'react'
import './App.css'

function App() {
  const [selectedRace, setSelectedRace] = useState(null)
  const [prediction, setPrediction] = useState(null)
  const [isAnalyzing, setIsAnalyzing] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState(null)
  const [isRealData, setIsRealData] = useState(false)
  const [allVenuesData, setAllVenuesData] = useState([])
  const [selectedVenueId, setSelectedVenueId] = useState(null)
  const [races, setRaces] = useState([])

  // レース場番号から名前へのマッピング
  const stadiumNames = {
    1: '桐生', 2: '戸田', 3: '江戸川', 4: '平和島', 5: '多摩川', 6: '浜名湖',
    7: '蒲郡', 8: '常滑', 9: '津', 10: 'びわこ', 11: '住之江', 12: '尼崎',
    13: '鳴門', 14: '丸亀', 15: '児島', 16: '宮島', 17: '徳山', 18: '下関',
    19: '若松', 20: '芦屋', 21: '福岡', 22: '唐津', 23: '大村', 24: '桐生'
  }

  // 実際のAPIからデータを取得
  useEffect(() => {
    const fetchRaceData = async () => {
      try {
        setLoading(true)
        setError(null)

        // 本番環境とローカル開発環境でAPIエンドポイントを切り替え
        const apiUrl = process.env.NODE_ENV === 'production'
          ? '/api/scrape-races'
          : 'http://localhost:3000/api/scrape-races'

        const response = await fetch(apiUrl)

        if (!response.ok) {
          throw new Error('スクレイピングAPIからデータを取得できませんでした')
        }

        const result = await response.json()

        if (!result.success || !result.data) {
          throw new Error('有効なデータが取得できませんでした')
        }

        // レース場データを保存
        setAllVenuesData(result.data)
        setIsRealData(true)

        // 最初に開催されているレース場を自動選択
        if (result.data.length > 0) {
          setSelectedVenueId(result.data[0].placeCd)
        }

      } catch (err) {
        console.error('API取得エラー:', err)
        setError(err.message)
        setIsRealData(false)
      } finally {
        setLoading(false)
      }
    }

    fetchRaceData()
  }, [])

  // レース場選択時にレース一覧を更新
  useEffect(() => {
    if (selectedVenueId && allVenuesData.length > 0) {
      const venueData = allVenuesData.find(v => v.placeCd === selectedVenueId)

      if (venueData && venueData.races) {
        // レースデータを表示用に変換
        const formattedRaces = venueData.races.map(race => {
          // レース番号から発走時刻を計算（1Rは10:30から、30分間隔）
          const baseHour = 10
          const baseMinute = 30
          const totalMinutes = baseMinute + (race.raceNo - 1) * 30
          const hour = baseHour + Math.floor(totalMinutes / 60)
          const minute = totalMinutes % 60

          return {
            id: `${race.date}-${race.placeCd}-${race.raceNo}`,
            venue: venueData.placeName,
            raceNumber: race.raceNo,
            startTime: `${hour}:${minute.toString().padStart(2, '0')}`,
            weather: race.weather || '不明',
            wave: race.waveHeight || 0,
            wind: race.windVelocity || 0,
            rawData: race // 元のデータも保持
          }
        })

        setRaces(formattedRaces)
      } else {
        setRaces([])
      }
    }
  }, [selectedVenueId, allVenuesData])

  const analyzeRace = (race) => {
    setSelectedRace(race)
    setIsAnalyzing(true)
    setPrediction(null)

    // AIによる予想をシミュレート
    setTimeout(() => {
      const players = generatePlayers()
      const aiPrediction = {
        topPick: players[0],
        recommended: players.slice(0, 3),
        allPlayers: players,
        confidence: Math.floor(Math.random() * 30) + 70,
        reasoning: [
          '過去10レースの勝率が高い',
          'モーター成績が優秀',
          '当該コースでの実績あり',
          '気象条件が有利',
        ]
      }
      setPrediction(aiPrediction)
      setIsAnalyzing(false)
    }, 2000)
  }

  const generatePlayers = () => {
    const names = ['山田太郎', '鈴木次郎', '佐藤三郎', '田中四郎', '伊藤五郎', '渡辺六郎']
    return names.map((name, idx) => ({
      number: idx + 1,
      name: name,
      age: 25 + Math.floor(Math.random() * 20),
      winRate: (Math.random() * 0.3 + 0.2).toFixed(3),
      motorNumber: Math.floor(Math.random() * 100) + 1,
      motorWinRate: (Math.random() * 0.2 + 0.3).toFixed(3),
      aiScore: Math.floor(Math.random() * 40) + 60 - idx * 8,
    })).sort((a, b) => b.aiScore - a.aiScore)
  }

  return (
    <div className="app">
      {/* ヘッダー広告バナー */}
      <div className="ad-banner header-ad">
        <div className="ad-content">
          📢 広告スペース (728x90) - ボートレース関連広告
        </div>
      </div>

      <header className="header">
        <div className="logo">
          <span className="logo-icon">🚤</span>
          <h1>ボートレースAI予想</h1>
        </div>
        <nav className="nav">
          <button className="nav-btn active">今日のレース</button>
          <button className="nav-btn">予想履歴</button>
          <button className="nav-btn">統計</button>
        </nav>
      </header>

      <div className="container">
        {/* サイドバー広告 */}
        <aside className="sidebar-ad">
          <div className="ad-banner vertical-ad">
            <div className="ad-content vertical">
              📢<br/>広告<br/>スペース<br/>(160x600)
            </div>
          </div>
        </aside>

        <main className="main-content">
          <section className="race-list-section">
            <h2>🏁 本日開催中のレース {isRealData && <span style={{fontSize: '0.8rem', color: '#22c55e', marginLeft: '1rem'}}>✓ 実データ</span>}</h2>

            {loading ? (
              <div className="analyzing">
                <div className="spinner"></div>
                <p>レースデータを読み込み中...</p>
              </div>
            ) : (
              <>
                {error && (
                  <div style={{padding: '1rem', background: '#fff3cd', borderRadius: '8px', marginBottom: '1rem'}}>
                    <p style={{color: '#856404'}}>⚠️ {error}</p>
                    <p style={{color: '#856404', fontSize: '0.9rem'}}>データ取得に失敗しました</p>
                  </div>
                )}

                {/* レース場選択ドロップダウン */}
                {allVenuesData.length > 0 && (
                  <div style={{marginBottom: '1.5rem'}}>
                    <label htmlFor="venue-select" style={{
                      display: 'block',
                      marginBottom: '0.5rem',
                      fontWeight: 'bold',
                      color: '#334155'
                    }}>
                      レース場を選択:
                    </label>
                    <select
                      id="venue-select"
                      value={selectedVenueId || ''}
                      onChange={(e) => setSelectedVenueId(parseInt(e.target.value))}
                      style={{
                        padding: '0.75rem 1rem',
                        fontSize: '1rem',
                        borderRadius: '8px',
                        border: '2px solid #e2e8f0',
                        backgroundColor: 'white',
                        cursor: 'pointer',
                        minWidth: '250px',
                        outline: 'none'
                      }}
                    >
                      {allVenuesData.map(venue => (
                        <option key={venue.placeCd} value={venue.placeCd}>
                          {venue.placeName} ({venue.races.length}レース)
                        </option>
                      ))}
                    </select>
                  </div>
                )}

                {races.length === 0 && !error ? (
                  <div style={{padding: '2rem', textAlign: 'center', color: '#64748b'}}>
                    <p>本日、このレース場での開催はありません</p>
                  </div>
                ) : (
                  <div className="race-grid">
                    {races.map(race => (
                      <div key={race.id} className="race-card">
                        <div className="race-card-header">
                          <h3>{race.venue}</h3>
                          <span className="race-number">{race.raceNumber}R</span>
                        </div>
                        <div className="race-info">
                          <div className="info-item">
                            <span className="label">発走時刻</span>
                            <span className="value">{race.startTime}</span>
                          </div>
                          <div className="info-item">
                            <span className="label">天候</span>
                            <span className="value">{race.weather}</span>
                          </div>
                          <div className="info-item">
                            <span className="label">波高</span>
                            <span className="value">{race.wave}cm</span>
                          </div>
                          <div className="info-item">
                            <span className="label">風速</span>
                            <span className="value">{race.wind}m</span>
                          </div>
                        </div>
                        <button
                          className="predict-btn"
                          onClick={() => analyzeRace(race)}
                        >
                          AI予想を見る
                        </button>
                      </div>
                    ))}
                  </div>
                )}
              </>
            )}
          </section>

          {/* 中央広告バナー */}
          <div className="ad-banner content-ad">
            <div className="ad-content">
              📢 広告スペース (728x90) - レース場関連広告
            </div>
          </div>

          {selectedRace && (
            <section className="prediction-section">
              <h2>📊 AI予想結果 - {selectedRace.venue} {selectedRace.raceNumber}R</h2>

              {isAnalyzing ? (
                <div className="analyzing">
                  <div className="spinner"></div>
                  <p>AIが分析中...</p>
                  <p className="analyzing-detail">過去データ、モーター性能、気象条件を解析しています</p>
                </div>
              ) : prediction && (
                <div className="prediction-result">
                  <div className="confidence-bar">
                    <div className="confidence-label">
                      AI信頼度: <strong>{prediction.confidence}%</strong>
                    </div>
                    <div className="bar">
                      <div
                        className="bar-fill"
                        style={{ width: `${prediction.confidence}%` }}
                      ></div>
                    </div>
                  </div>

                  <div className="top-pick">
                    <h3>🥇 本命予想</h3>
                    <div className="player-card featured">
                      <div className="player-number">{prediction.topPick.number}</div>
                      <div className="player-details">
                        <h4>{prediction.topPick.name}</h4>
                        <div className="stats">
                          <span>年齢: {prediction.topPick.age}歳</span>
                          <span>勝率: {prediction.topPick.winRate}</span>
                          <span>モーター: {prediction.topPick.motorWinRate}</span>
                        </div>
                      </div>
                      <div className="ai-score">
                        <div className="score-label">AIスコア</div>
                        <div className="score-value">{prediction.topPick.aiScore}</div>
                      </div>
                    </div>
                  </div>

                  <div className="reasoning">
                    <h4>📌 予想根拠</h4>
                    <ul>
                      {prediction.reasoning.map((reason, idx) => (
                        <li key={idx}>{reason}</li>
                      ))}
                    </ul>
                  </div>

                  <div className="all-players">
                    <h4>全艇情報</h4>
                    <table className="players-table">
                      <thead>
                        <tr>
                          <th>艇番</th>
                          <th>選手名</th>
                          <th>年齢</th>
                          <th>勝率</th>
                          <th>モーター</th>
                          <th>AIスコア</th>
                        </tr>
                      </thead>
                      <tbody>
                        {prediction.allPlayers.map(player => (
                          <tr key={player.number} className={player.number <= 3 ? 'recommended' : ''}>
                            <td><strong>{player.number}</strong></td>
                            <td>{player.name}</td>
                            <td>{player.age}</td>
                            <td>{player.winRate}</td>
                            <td>{player.motorWinRate}</td>
                            <td><span className="score-badge">{player.aiScore}</span></td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}
            </section>
          )}
        </main>

        {/* サイドバー広告（右） */}
        <aside className="sidebar-ad">
          <div className="ad-banner vertical-ad">
            <div className="ad-content vertical">
              📢<br/>広告<br/>スペース<br/>(160x600)
            </div>
          </div>
        </aside>
      </div>

      {/* フッター広告バナー */}
      <div className="ad-banner footer-ad">
        <div className="ad-content">
          📢 広告スペース (728x90) - ボート用品・グッズ広告
        </div>
      </div>

      <footer className="footer">
        <p>※本サイトはAIによる予想を提供するものであり、的中を保証するものではありません</p>
        <p>&copy; 2025 ボートレースAI予想 - All Rights Reserved</p>
      </footer>
    </div>
  )
}

export default App;
```

### タスク 4.3: main.jsxの確認

`src/main.jsx`を開き、以下の内容になっていることを確認します。

```javascript
// src/main.jsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.jsx'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

### タスク 4.4: index.htmlの更新

`index.html`を開き、タイトルとメタタグを更新します。

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="ボートレースAI予測アプリケーション - リアルタイムでレース情報を取得し、AI分析による予測を提供" />
    <title>ボートレースAI予想</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

## Step 5: ローカル環境での動作確認

### タスク 5.1: Vercel CLI のインストールと起動

ローカル環境でVercel API Routesをテストするには、Vercel CLIが必要です。

```bash
# Vercel CLIをグローバルにインストール（初回のみ）
npm install -g vercel

# Vercel開発サーバーを起動
vercel dev
```

初回起動時、Vercelアカウントへのログインとプロジェクトのセットアップが求められます。画面の指示に従って設定してください。

**注**: `npm run dev`（Vite開発サーバー）を使用すると、APIエンドポイントが動作せずエラーが表示されます。必ず `vercel dev` を使用してください。

### タスク 5.2: 動作確認

ブラウザで`http://localhost:3000`にアクセスし、以下を確認します：

1. 実際のレースデータが取得できること（初回は30-60秒かかる場合があります）
2. レース場選択ドロップダウンが機能すること
3. AI予想ボタンが機能すること
4. レスポンシブデザインが機能すること

### タスク 5.3: スクレイピング動作の確認

以下のコマンドでスクレイピング機能を単独テストできます：

```bash
node test-scraping.js
```

このテストスクリプトは、1つのレース場の1レースのみをスクレイピングして結果を表示します。

## Step 6: robots.txtとスクレイピングマナーの確認

### タスク 6.1: robots.txtの確認

以下のURLにアクセスし、スクレイピングが許可されているか確認します。

```
https://www.boatrace.jp/robots.txt
```

もし特定のパスが`Disallow`されている場合は、スクレイピングを避けてください。

### タスク 6.2: スクレイピング実装の動作確認

`api/scrape-races.js`のスクレイピング処理は、実際のボートレース公式サイト（https://www.boatrace.jp/owpc/pc/race/beforeinfo）から直前情報を取得する実装となっています。

以下のセレクタが使用されています：
- 天候データ: `.weather1_bodyUnitLabelData`
- 天気テキスト: `.weather1_bodyUnitLabelTitle`
- 風向: `p[class*="is-wind"]`
- 展示タイム・チルト: `.is-fs12`
- スタート展示: `.table1_boatImage1`

HTMLの構造が変更された場合は、これらのセレクタを適宜修正してください。

## Step 7: Vercelへのデプロイ

### タスク 7.1: Gitリポジトリの初期化と初回コミット

```bash
git init
git add .
git commit -m "Initial commit: Boatrace AI app with web scraping"
```

### タスク 7.2: GitHubリポジトリの作成とプッシュ

GitHub上で新しいリポジトリを作成し、プッシュします。

```bash
git remote add origin https://github.com/YOUR_USERNAME/boatrace-ai-predictor.git
git branch -M main
git push -u origin main
```

### タスク 7.3: Vercelでのデプロイ

1. [Vercel](https://vercel.com)にアクセスし、GitHubアカウントでログイン
2. 「Add New Project」をクリック
3. GitHubリポジトリ「boatrace-ai-predictor」をインポート
4. プロジェクト設定を確認:
   - Framework Preset: **Vite**
   - Build Command: `npm run build`
   - Output Directory: `dist`
5. 「Deploy」ボタンをクリック
6. デプロイ完了後、本番URLが発行される

### タスク 7.4: 本番環境での動作確認

発行されたURLにアクセスし、以下を確認します：

1. スクレイピングAPIが正常に動作すること
2. 実データが取得できること（または適切にフォールバックすること）
3. すべての機能が正常に動作すること

### タスク 7.5: トラブルシューティング

もしスクレイピングが失敗する場合：

1. Vercelのログを確認（Deployments > Function Logs）
2. HTMLセレクタが正しいか確認
3. User-Agentやヘッダーの設定を確認
4. キャッシュが正常に動作しているか確認

## Step 8: スクレイピングマナーの遵守

### タスク 8.1: アクセス頻度の監視

Vercelダッシュボードで、API Routesの呼び出し回数を監視します。過度なアクセスがないことを確認してください。

### タスク 8.2: キャッシュの確認

5分間のキャッシュが正常に機能していることを確認します。

```bash
# Vercel Function Logsで確認
# "Returning cached data" のログが出ていればキャッシュが機能している
```

### タスク 8.3: 利用規約の最終確認

ボートレース公式サイトの利用規約を再度確認し、スクレイピングが許可されているか、または禁止されていないことを確認してください。

もし利用規約でスクレイピングが明示的に禁止されている場合は、**公式APIへの切り替え**を検討してください。

## 完了

以上で、Webスクレイピング対応のボートレースAI予測アプリケーションの実装が完了しました。

### 実装した主要機能

✅ Vercelサーバーレス関数（API Routes）
✅ Cheerioを使用したスクレイピング
✅ キャッシュ機能（5分間）
✅ レース場選択機能（24レース場対応）
✅ AI予測機能（簡易実装）
✅ エラーハンドリングとサンプルデータフォールバック
✅ レスポンシブデザイン
✅ スクレイピングマナーの遵守

### 重要な注意事項

⚠️ **利用規約の確認**: ボートレース公式サイトの利用規約を必ず確認し、遵守してください

⚠️ **robots.txtの遵守**: スクレイピング対象パスが許可されているか確認してください

⚠️ **HTMLセレクタの保守**: ボートレース公式サイトのHTML構造が変更された場合、`api/scrape-races.js`のセレクタを適宜修正してください

### 次のステップ（オプション）

- より詳細なエラーハンドリング
- スクレイピング結果のデータ検証強化
- ログ監視と異常検知
- 実際の選手データを使用したAI予測機能の強化

---

**実装完了日**: 2025-11-27
**対象プロジェクト**: ボートレースAI予測アプリケーション（スクレイピング版）
**バージョン**: 2.0
