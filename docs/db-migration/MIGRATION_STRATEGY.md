# DB移行戦略 - 本番影響を最小化する移行計画

## 📋 概要

このドキュメントは、**本番環境への影響を最小限に抑えながら**、JSONファイルからPostgreSQLデータベース（Supabase）への移行を安全に実行するための戦略を説明します。

---

## 🎯 移行の基本方針

### 1. 段階的移行（Gradual Migration）
- **JSONとDBの併用期間を設ける**（デュアルライト）
- 移行完了後もJSON出力を維持（後方互換性）
- 問題発生時は即座にJSONにロールバック可能

### 2. ゼロダウンタイム移行
- **ユーザーへの影響をゼロにする**
- 移行中も既存のJSONファイルでサービス継続
- API切り替えは段階的に実施

### 3. データ整合性の確保
- 移行前後のデータ検証を徹底
- トランザクション管理で整合性を保証
- ロールバック計画を事前に準備

---

## 📅 移行タイミングの推奨

### ⚠️ 避けるべきタイミング

1. **レース開催時間中（10:00-17:00 JST）**
   - ユーザーアクセスが集中
   - データ更新が頻繁
   - 問題発生時の影響が大きい

2. **週末・祝日**
   - レース開催が集中
   - トラブル対応が困難

3. **データ更新直後**
   - GitHub Actions実行直後（例: 10:00, 11:00）
   - データが更新中の可能性

4. **GitHub Actions実行中**
   - 20:00のGitHub Actions実行中は避ける
   - 実行完了を確認してから開始

### ✅ 推奨されるタイミング

#### フェーズ1-4: 開発・テスト環境での実装
**推奨時期:** いつでも（本番影響なし）

- スキーマ作成
- データ移行スクリプト作成
- スクリプトのDB対応
- ローカル環境でのテスト

**所要時間:** 1-2週間

---

#### フェーズ5-6: ステージング環境での検証
**推奨時期:** 平日の深夜（0:00-6:00 JST）または 20:00-22:00 JST

**理由:**
- ユーザーアクセスが少ない
- レース開催がない
- 問題発生時の対応が可能

**実施内容:**
- ステージング環境にAPI実装
- フロントエンドのAPI対応
- 動作確認とパフォーマンステスト

**所要時間:** 1週間

---

#### フェーズ7: 本番データ移行
**推奨時期1:** **平日の深夜2:00-4:00 JST（最推奨）**

**理由:**
- ユーザーアクセスが最も少ない時間帯
- レース開催がない
- GitHub Actionsの実行間隔（1時間）を考慮
- 問題発生時の対応時間を確保

**推奨時期2:** **平日の20:00-22:00 JST（代替案）**

**理由:**
- レース開催が終了している（17:00以降）
- 対応可能な時間帯
- ユーザーアクセスはあるが、レース開催中より少ない

**⚠️ 20時実施時の注意事項:**
- GitHub Actionsの実行タイミング（20:00）と重なる可能性
- ユーザーアクセスがあるため、段階的切り替えが重要
- 問題発生時の対応体制を確保

**実施手順（20:00開始の場合）:**
1. **19:30 JST** - 事前準備
   - 最新のJSONデータをバックアップ
   - 移行スクリプトの最終確認
   - 監視体制の確認

2. **20:00 JST** - GitHub Actions実行後を確認
   - 20:00のGitHub Actions実行完了を待つ（約5分）
   - 最新のJSONデータをDBに移行開始
   - データ検証実行

3. **20:30 JST** - 検証完了
   - データ整合性確認
   - パフォーマンステスト
   - APIエンドポイントの動作確認

4. **21:00 JST** - 段階的切り替え開始
   - 10%のトラフィックをAPI経由に
   - エラー監視を強化
   - ユーザー影響を確認

5. **21:30 JST** - 拡大（問題なければ）
   - 50%のトラフィックをAPI経由に
   - 継続的な監視

6. **22:00 JST** - 完全切り替え（問題なければ）
   - 100%のトラフィックをAPI経由に
   - JSONファイルはバックアップとして維持

**所要時間:** 約2時間（20:00-22:00）

**20時実施のメリット:**
- ✅ 対応可能な時間帯
- ✅ レース開催が終了している
- ✅ 問題発生時の対応が容易

**20時実施のデメリット:**
- ⚠️ ユーザーアクセスがある（段階的切り替えが必須）
- ⚠️ GitHub Actionsの実行タイミングと重なる可能性
- ⚠️ 深夜よりリスクが高い

---

#### フェーズ8: 本番デプロイ
**推奨時期:** 平日の深夜2:00-4:00 JST（フェーズ7と同時）

**実施内容:**
- 本番DB環境へのデータ移行
- Vercelへのデプロイ
- モニタリング設定

---

## 🔄 段階的移行戦略（デュアルライト）

### ステップ1: DB書き込み開始（JSONも継続）

**期間:** 1-2週間

**実装:**
```javascript
// scripts/scrape-to-json.js
if (process.env.USE_DATABASE === 'true') {
  // DBに書き込み
  await insertRacesToDB(racesData);
}
// JSONファイルにも書き込み（常に実行）
await fs.writeFile(outputPath, JSON.stringify(outputData, null, 2));
```

**メリット:**
- DBとJSONの両方にデータを保存
- 問題発生時はJSONに即座に切り替え可能
- データ整合性を検証可能

**監視:**
- DB書き込みエラーの監視
- JSONとDBのデータ件数比較

---

### ステップ2: API実装（JSON読み込みは継続）

**期間:** 1週間

**実装:**
```javascript
// src/App.jsx
const fetchRaceData = async () => {
  try {
    // API経由で取得を試行
    const response = await fetch('/api/races?date=' + date);
    if (response.ok) {
      const data = await response.json();
      return data;
    }
  } catch (error) {
    console.warn('API取得失敗、JSONファイルにフォールバック');
  }
  
  // API失敗時はJSONファイルにフォールバック
  const response = await fetch('/data/races.json');
  return await response.json();
};
```

**メリット:**
- API失敗時もJSONでサービス継続
- 段階的にAPI使用率を増やせる

---

### ステップ3: 段階的トラフィック切り替え

**期間:** 1週間

**実装:**
```javascript
// 環境変数でAPI使用率を制御
const USE_API = process.env.VITE_USE_API === 'true';
const API_USAGE_RATE = parseFloat(process.env.VITE_API_USAGE_RATE || '0');

if (USE_API && Math.random() < API_USAGE_RATE) {
  // API経由で取得
} else {
  // JSONファイル経由で取得
}
```

**切り替えスケジュール:**
- 1日目: 10%のトラフィックをAPI経由に
- 2-3日目: 30%のトラフィックをAPI経由に
- 4-5日目: 50%のトラフィックをAPI経由に
- 6-7日目: 100%のトラフィックをAPI経由に

**監視:**
- APIエラー率
- レスポンス時間
- ユーザー影響の有無

---

### ステップ4: JSON読み込みの廃止（オプション）

**期間:** 移行完了後1ヶ月

**条件:**
- APIが1ヶ月間安定稼働
- エラー率が0.1%以下
- パフォーマンスがJSONと同等以上

**実装:**
- JSONファイル読み込みコードを削除
- JSONファイル出力を停止（オプション）

---

## 🛡️ 本番影響を最小化する対策

### 1. ロールバック計画

#### 即座にロールバック可能な設計

**環境変数による切り替え:**
```bash
# JSONに戻す（即座に実行可能）
USE_DATABASE=false
VITE_USE_API=false
```

**GitHub Actionsの設定:**
```yaml
# .github/workflows/scrape.yml
env:
  USE_DATABASE: ${{ secrets.USE_DATABASE || 'false' }}
```

**Vercel環境変数:**
- `USE_DATABASE=false` に設定するだけでJSONに戻せる
- デプロイ不要（環境変数のみ変更）

---

### 2. データ整合性の確保

#### デュアルライト期間中の検証

**自動検証スクリプト:**
```javascript
// scripts/db/validate-dual-write.js
// JSONとDBのデータを比較
// 1時間ごとに実行（GitHub Actions）
```

**検証項目:**
- データ件数の一致
- サンプルデータの内容一致
- 最新データの整合性

**アラート:**
- 不一致が検出されたら即座に通知
- JSONへの切り替えを推奨

---

### 3. パフォーマンス監視

#### 監視指標

**APIパフォーマンス:**
- レスポンス時間（目標: 1秒以内）
- エラー率（目標: 0.1%以下）
- スループット（目標: JSONと同等以上）

**データベース:**
- クエリ実行時間
- 接続プールの使用率
- ストレージ使用量

**アラート設定:**
- レスポンス時間が2秒を超えたら警告
- エラー率が1%を超えたら警告
- DB接続エラーが発生したら即座に通知

---

### 4. 段階的ロールアウト

#### カナリアリリース

**実装:**
```javascript
// ユーザーIDのハッシュでAPI使用を制御
const userId = getUserId(); // セッションIDなど
const useApi = hashUserId(userId) % 100 < API_USAGE_RATE;
```

**メリット:**
- 特定のユーザーグループのみAPI経由に
- 問題発生時の影響範囲を限定
- 段階的に拡大可能

---

### 5. フォールバック機能

#### API失敗時の自動フォールバック

**実装:**
```javascript
const fetchWithFallback = async (apiUrl, jsonUrl) => {
  try {
    const response = await fetch(apiUrl);
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    console.warn('API失敗、JSONにフォールバック:', error);
  }
  
  // JSONファイルにフォールバック
  const response = await fetch(jsonUrl);
  return await response.json();
};
```

**メリット:**
- API障害時もサービス継続
- ユーザーへの影響を最小化

---

## 📊 移行スケジュール（推奨）

### 週次スケジュール

| 週 | フェーズ | 実施内容 | 本番影響 |
|---|---------|---------|---------|
| **1週目** | フェーズ1-4 | 開発・実装 | なし |
| **2週目** | フェーズ1-4 | 開発・実装 | なし |
| **3週目** | フェーズ5-6 | ステージング検証 | なし |
| **4週目** | フェーズ7 | **本番データ移行（20:00-22:00推奨）** | **最小限（段階的切り替え）** |
| **5週目** | フェーズ8 | 本番デプロイ・監視 | なし |
| **6-9週目** | デュアルライト | JSONとDB併用 | なし |
| **10週目以降** | 完全移行 | JSON廃止（オプション） | なし |

---

## ⚠️ リスク管理

### リスク1: データ不整合

**対策:**
- デュアルライト期間中に自動検証
- トランザクション管理で整合性を保証
- 問題検出時は即座にJSONに切り替え

**影響度:** 高
**発生確率:** 低
**対策効果:** 高

---

### リスク2: APIパフォーマンス低下

**対策:**
- 段階的トラフィック切り替え
- パフォーマンス監視とアラート
- フォールバック機能でJSONに自動切り替え

**影響度:** 中
**発生確率:** 中
**対策効果:** 高

---

### リスク3: DB接続エラー

**対策:**
- 接続プールの適切な設定
- リトライロジックの実装
- フォールバック機能でJSONに自動切り替え

**影響度:** 高
**発生確率:** 低
**対策効果:** 高

---

### リスク4: 移行中のデータ更新

**対策:**
- 移行は深夜（2:00-4:00）または20:00-22:00に実施
- GitHub Actionsの実行タイミングを確認（20:00実行後を待つ）
- 移行前に最新データを取得
- 20時実施時は実行完了を待ってから開始

**影響度:** 中
**発生確率:** 中
**対策効果:** 高

---

### リスク5: 20時実施時のユーザーアクセス

**対策:**
- 段階的トラフィック切り替え（10% → 50% → 100%）
- フォールバック機能でJSONに自動切り替え
- リアルタイム監視とアラート
- 問題検出時は即座にロールバック

**影響度:** 中
**発生確率:** 中
**対策効果:** 高

---

## 🔍 移行前チェックリスト

### 技術的準備
- [ ] スキーマが正しく作成されている
- [ ] データ移行スクリプトが動作する
- [ ] APIエンドポイントが正常に動作する
- [ ] フォールバック機能が実装されている
- [ ] ロールバック手順が文書化されている

### データ準備
- [ ] 既存のJSONデータがバックアップされている
- [ ] データ検証スクリプトが準備されている
- [ ] サンプルデータでのテストが完了している

### 運用準備
- [ ] 監視とアラートが設定されている
- [ ] ロールバック手順が確認されている
- [ ] 緊急連絡先が確認されている
- [ ] 移行タイミングが決定されている

---

## 📞 緊急時の対応手順

### 問題発生時の即座の対応

1. **環境変数を変更（5分以内）**
   ```bash
   # Vercel環境変数
   USE_DATABASE=false
   VITE_USE_API=false
   ```

2. **GitHub Actionsの環境変数を変更（5分以内）**
   ```bash
   # GitHub Secrets
   USE_DATABASE=false
   ```

3. **動作確認（10分以内）**
   - フロントエンドがJSONファイルを読み込んでいるか確認
   - スクリプトがJSONファイルに書き込んでいるか確認

4. **原因調査（30分以内）**
   - エラーログを確認
   - データ整合性を確認
   - パフォーマンスを確認

---

## ✅ 移行完了の定義

### 移行成功の条件

1. **データ整合性**
   - JSONとDBのデータが一致
   - 検証スクリプトが1週間エラーなし

2. **パフォーマンス**
   - APIレスポンス時間が1秒以内
   - エラー率が0.1%以下
   - JSONと同等以上のパフォーマンス

3. **安定性**
   - 1週間連続でエラーなし
   - ユーザーからの問題報告なし

4. **運用性**
   - 監視とアラートが正常に動作
   - ロールバック手順が確認済み

---

## 📚 参考資料

- [DB_MIGRATION_PLAN.md](./DB_MIGRATION_PLAN.md) - 詳細な移行計画
- [TECH_STACK_COMPATIBILITY.md](./TECH_STACK_COMPATIBILITY.md) - 技術スタック互換性
- [システム動作仕様.md](../../システム動作仕様.md) - 現在のシステム仕様

